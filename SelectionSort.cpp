/*** 选择排序：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序的元素中继续寻找最小（大）元素，存放到已经排序序列的末尾，依此类推，知道所有元素均排序完成为止。 ***/
/*** 选择排序和冒泡排序的思想类似，都是在一次排序后把最小的元素放到最前面。但过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值换至无序区最前面的位置 ***/
/*** 第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换
 * 第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换
 * 依次类推下去...... ***/
/*** 平均时间复杂度O(n^2),空间复杂度O(1),排序方式：In-place，稳定性:不稳定 ***/
#include<iostream>

using namespace std;

void SelectionSort(int arr[],int len)
{
	int i,j,min,temp;
	for(i=0;i<len-1;i++)
	{
		min=i;
		for(j=i+1;j<len;j++)
			if(arr[min]>arr[j])
				min=j;
              //swap(arr[i],arr[min]);
		temp=arr[min];
		arr[min]=arr[i];
		arr[i]=temp;
	}
}


//改进思路：二元选择排序。简单选择排序，每趟循环只能确定一个元素排序后的定位。根据之前冒泡排序的经验，我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。
//改进思路：堆排序是一种树形选择排序，是对直接选择排序的有效改进。具体的分析我们留到后面讲堆排序时再详细说明。
//选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。
//在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

int main()
{
int arr[10]={3,5,6,3,55,34,32,98,12,35};
SelectionSort(arr,10);
int i=0;
for(;i<10;i++)
  cout<<arr[i]<<' ';

return 0;
}
