/*** 希尔排序实质就是分组插入排序，是插入排序法的一种改进，希尔排序是非稳定的排序方法。***/
/*** 基本思想：先将整个待排序序列分割成若干子序列（由相隔某个“增量”的元素组成）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。开始时，gap取值较大，子序列中的元素较少，排序速度快，克服了直接插入排序的缺点；其次，当gap值逐渐减小后，虽然子序列的元素变多，但大多基本有序，所以继承了直接插入排序的有点 ***/
/*** 平均时间复杂度：O(nlog2(n))；空间复杂度：O(1)  ***/
/*** 希尔排序的效率取决于增量gap的选取，时间复杂度并不是一个定值，一般步长取一半***/

/*** 例子：假设有一组｛9, 1, 2, 5, 7, 4, 8, 6, 3, 5｝序列。
 * 第一趟排序：
 * 设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。
 * 第二趟排序：
 * 将上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。
 * 第三趟排序：
 * 再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。***/


#include<iostream>

using namespace std;

//严格按照定义写的希尔排序
void ShellSort(int arr[],int n)
{
	int i,j,gap;
	for(gap=n/2;gap>0;gap/=2)
		for(i=0;i<gap;i++)
		{
			for(j=i+gap;j<n;j+=gap)
			{
				int temp=arr[j];
				int k=j-gap;
				while(k>=0 && arr[k]>temp)
				{
					arr[k+gap]=arr[k];
					k-=gap;
				}
				arr[k+gap]=temp;
			}
		}
}


int main()
{
	int arr[10]={2,3,4,1,2,11,33,8,7,45};
	ShellSort(arr,10);
	int i;
	for(i=0;i<10;i++)
		cout<<arr[i]<<endl;
}
